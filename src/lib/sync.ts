import fs from "node:fs";
import path from "node:path";
import { SyncResult } from "./types";

function normalize(content: string): string {
	return `${content.trimEnd()}\n`;
}

function convertMarkdownToAsciiDoc(markdown: string): string {
	const lines = markdown.split("\n");
	const out: string[] = [];
	let inCode = false;
	let fenceLang = "text";

	for (const line of lines) {
		if (line.startsWith("```") && !inCode) {
			fenceLang = line.replace(/```+\s*/, "").trim() || "text";
			out.push(`[source,${fenceLang}]`);
			out.push("----");
			inCode = true;
			continue;
		}
		if (line.startsWith("```") && inCode) {
			out.push("----");
			inCode = false;
			continue;
		}
		if (inCode) {
			out.push(line);
			continue;
		}

		let converted = line;
		if (converted.startsWith("### ")) converted = `=== ${converted.slice(4)}`;
		else if (converted.startsWith("## "))
			converted = `== ${converted.slice(3)}`;
		else if (converted.startsWith("# ")) converted = `= ${converted.slice(2)}`;

		if (converted.startsWith("- ")) converted = `* ${converted.slice(2)}`;

		converted = converted.replace(/\[([^\]]+)\]\(([^)]+)\)/g, "link:$2[$1]");
		converted = converted.replace(/`([^`]+)`/g, "+$1+");

		out.push(converted);
	}

	if (inCode) {
		throw new Error("Unclosed fenced code block in docs/index.md");
	}

	return normalize(out.join("\n"));
}

function buildReadme(markdown: string): string {
	const banner =
		"<!-- Synced from docs/index.md via n00menon sync. Edit the source and rerun n00menon sync. -->\n\n";
	const body = markdown.replace(/^#\s+n00menon Docs/m, "# n00menon");
	return normalize(`${banner}${body}`);
}

export function syncDocs(
	filePaths: { source: string; readme: string; antora: string },
	options: { check?: boolean } = {}
): SyncResult[] {
	const results: SyncResult[] = [];
	const { source, readme: readmePath, antora: antoraPath } = filePaths;

	if (!fs.existsSync(source)) {
		throw new Error(`Source file missing: ${source}`);
	}

	const markdown = normalize(fs.readFileSync(source, "utf8"));
	const readmeContent = buildReadme(markdown);
	const adocContent = normalize(
		`// Generated from docs/index.md via n00menon sync.\n// Do not edit this file directly.\n\n${convertMarkdownToAsciiDoc(markdown)}`
	);

	// Sync README
	const currentReadme = fs.existsSync(readmePath)
		? fs.readFileSync(readmePath, "utf8")
		: "";

	if (currentReadme !== readmeContent) {
		if (!options.check) {
			fs.writeFileSync(readmePath, readmeContent, "utf8");
		}
		results.push({
			source,
			target: readmePath,
			synced: !options.check,
			changes: "Content updated"
		});
	} else {
         results.push({
			source,
			target: readmePath,
			synced: true
		});
    }

	// Sync Antora
	const currentAdoc = fs.existsSync(antoraPath)
		? fs.readFileSync(antoraPath, "utf8")
		: "";

	if (currentAdoc !== adocContent) {
		if (!options.check) {
            // Ensure dir exists
            fs.mkdirSync(path.dirname(antoraPath), { recursive: true });
			fs.writeFileSync(antoraPath, adocContent, "utf8");
		}
		results.push({
			source,
			target: antoraPath,
			synced: !options.check,
			changes: "Content updated"
		});
	} else {
        results.push({
			source,
			target: antoraPath,
			synced: true
		});
    }

	return results;
}
